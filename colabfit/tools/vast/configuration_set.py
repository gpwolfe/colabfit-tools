from collections import namedtuple
from hashlib import sha512

from pyspark.sql import functions as sf

from colabfit.tools.vast.schema import configuration_set_schema
from colabfit.tools.vast.utilities import (
    ELEMENT_MAP,
    _empty_dict_from_schema,
    get_last_modified,
)


class ConfigurationSet:
    """
    A configuration set defines a group of configurations and aggregates
    information about those configurations to improve queries.

    Note that a configuration set should only be constructed by loading from an
    existing database (in order to aggregate the info)

    Attributes:

        configuration_ids (list):
            A list of all attached configuration IDs

        description (str):
            A human-readable description of the configuration set

        aggregated_info (dict):
            A dictionary of information that was aggregated from all of the
            attached configurations. Contains the following information:

                * nconfigurations: the total number of configurations
                * nsites: the total number of sites
                * nelements: the total number of unique element types
                * elements: the element types
                * individual_elements_ratios: a set of elements ratios generated by
                  looping over each configuration, extracting its concentration of each
                  element, and adding the tuple of concentrations to the set
                * total_elements_ratios: the ratio of the total count of atoms of each
                  element type over nsites
                * chemical_formula_reduced: the set of all reduced chemical formulae
                * chemical_formula_anonymous: the set of all anonymous chemical formulae
                * chemical_formula_hill: the set of all hill chemical formulae
                * nperiodic_dimensions: the set of all numbers of periodic dimensions
                * dimension_types: the set of all periodic boundary choices

    """

    def __init__(self, config_df, name, description, dataset_id, ordered=False):
        self.name = name
        self.description = description
        self.dataset_id = dataset_id
        self.ordered = ordered
        self.row_dict = self.to_row_dict(config_df)
        self.id = f"CS_{self.name}_{self.dataset_id}"
        self._hash = hash(self)
        self.row_dict["id"] = self.id
        self.row_dict["extended_id"] = self.id
        self.row_dict["hash"] = str(self._hash)

    def to_row_dict(self, config_df):
        row_dict = _empty_dict_from_schema(configuration_set_schema)
        row_dict["name"] = self.name
        row_dict["description"] = self.description
        row_dict["dataset_id"] = self.dataset_id
        config_df = config_df.drop_duplicates(["id"])
        config_df.cache()
        agg_df = config_df.agg(
            sf.count("id").alias("nconfigurations"),
            sf.sum("nsites").alias("nsites"),
            sf.collect_set("nperiodic_dimensions").alias("nperiodic_dimensions"),
            sf.collect_set("dimension_types").alias("dimension_types"),
            sf.array_distinct(sf.flatten(sf.collect_set("elements"))).alias("elements"),
        )
        agg_row = agg_df.collect()[0]
        row_dict["nconfigurations"] = agg_row["nconfigurations"]
        row_dict["nsites"] = agg_row["nsites"]
        row_dict["nperiodic_dimensions"] = agg_row["nperiodic_dimensions"]
        row_dict["dimension_types"] = agg_row["dimension_types"]
        row_dict["elements"] = sorted(list(set(agg_row["elements"])))
        row_dict["nelements"] = len(row_dict["elements"])
        row_dict["last_modified"] = get_last_modified()
        atomic_ratios_df = (
            config_df.select("atomic_numbers")
            .withColumn("single_element", sf.explode("atomic_numbers"))
            .groupBy("single_element")
            .agg(sf.count("single_element").alias("count"))
        )
        total_elements = atomic_ratios_df.agg(sf.sum("count")).collect()[0][0]
        atomic_ratios_df = atomic_ratios_df.withColumn(
            "ratio", sf.col("count") / total_elements
        )
        print(total_elements, row_dict["nsites"])
        assert total_elements == row_dict["nsites"]
        element_map_expr = sf.create_map(
            [
                sf.lit(k)
                for pair in [(k, v) for k, v in ELEMENT_MAP.items()]
                for k in pair
            ]
        )
        atomic_ratios_coll = (
            atomic_ratios_df.withColumn(
                "element", element_map_expr[sf.col("single_element")]
            )
            .select("element", "ratio")
            .collect()
        )
        row_dict["total_elements_ratios"] = [
            x[1] for x in sorted(atomic_ratios_coll, key=lambda x: x["element"])
        ]
        config_df.unpersist()
        return row_dict

    def __hash__(self):
        cs_hash = sha512()
        cs_hash.update(self.id.encode("utf-8"))
        return int(cs_hash.hexdigest(), 16)

    def __str__(self):
        return "ConfigurationSet(description='{}', nconfigurations={})".format(
            self.description,
            self.row_dict["nconfigurations"],
        )

    def __repr__(self):
        return str(self)


configuration_set_info = namedtuple(
    "configuration_set_info",
    [
        "co_name_match",
        "co_label_match",
        "cs_name",
        "cs_description",
    ],
)
